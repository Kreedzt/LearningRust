* RefCell<T> 和内部可变性模式
  *内部可变性(interior mutability)* 是 Rust 中的一个设计模式, 它允许即使在有不可
   变引用时也可以改变数据, 这通常是借用规则所不允许的. 为了改变数据, 该模式在数
   据结构中使用 ~unsafe~ 代码来模式 Rust 通常的可变性和借用规则(19 章). 当可以确
   保代码在运行时会遵守借用规则, 即使编译器不能保证的情况, 可以选择使用那些运用
   内部可变性模式的类型. 所涉及的 ~unsafe~ 代码将被封装进安全的 API 中, 而外部类
   型仍然是不可变的.

** 通过 RefCell<T> 在运行时检查借用规则
   不同于 ~Rc<T>~, ~RefCell<T>~ 代表其数据的唯一的所有权.
   
   借用规则(第四章):
   1. 在任何给定时刻, 只能拥有一个可变引用或任意数量的不可变引用 *之一(而不是两者)*
   2. 引用必须总是有效的
      
      
   对于引用和 ~Box<T>~, 借用规则的不可变性作用域编译时. 对于 ~RefCell<T>~, 这些
   不可变性作用于 *运行时*. 对于引用, 如果违反这些规则, 会得到一个编译错误. 而对
   于 ~RefCell<T>~, 如果违反这些规则程序会 panic 并退出.

   在运行时借用检查规则的好处则是允许出现特定内存安全的场景, 而它们在编译时检查
   中是不允许的. 静态分析, eg: Rust 编译器, 是天生保守的. 但代码的一些属性不可能
   通过分析代码发现: 最著名的就是 *停机问题(Halting Problem)*, 这超出了本书的范
   畴.

   因为一些分析是不可能的, 如果 Rust 编译器不能通过所有权规则编译, 可能会拒绝一
   个正确的程序. ~RefCell<T>~ 正式用于当你确信代码遵守借用规则, 而编译器不能理解
   和确定的时候.

   类似于 ~Rc<T>~, ~RefCell<T>~ 只能用于单线程场景. 如果尝试在多线程上下文中使用
   ~RefCell<T>~, 会得到一个编译错误. (16 章会介绍如何使用该功能)

   选择 ~Box<T>~, ~Rc<T>~, 或 ~RefCell<T>~ 的理由:
   - ~Rc<T>~ 允许相同数据有多个所有者; ~Box<T>~ 和 ~RefCell<T>~ 有单一所有者.
   - ~Box<T>~ 允许在编译时执行不可变或可变借用检查; ~Rc<T>~ 仅允许在编译时执行不
     可变借用检查; ~RefCel<T>~ 允许在运行时执行不可变或可变借用检查.
   - 因为 ~RefCell<T>~ 允许在运行时执行可变借用检查, 所以我们可以在即便
     ~RefCell<T>~ 自身是不可变的情况下修改其内部的值.

     
   在不可变值内部改变值就是 *内部可变性* 模式.

** 内部可变性: 不可变值的可变借用
   借用的规则是一个推论是当有一个不可变值时, 可能可变地借用它.

   特定情况下, 令一个值在其方法内部能够修改自身, 而在其他代码中仍视为不可变, 是
   很有用的. 值方法外部的代码就不能修改其值了. ~RefCell<T>~ 是一个获取内部可变性
   的方法. ~RefCell<T>~ 并没有完全绕开借用规则, 编译器中的借用检查器允许内部可变
   性并相应地在运行时检查借用规则. 如果违反了这些规则, 会出现 panic 而不是编译错
   误

*** 内部可变性的用例: mock 对象
    *测试替身(test double)* 是一个通用编程概念, 它代表一个在测试中替代某个类型的
     类型. ~mock 对象* 是特定类型的测试替身, 它们记录测试过程中发生了什么以便可
     以断言操作是正确的.

    虽然 Rust 中的对象与其他语言中的对象并不是一回事, Rust 也没有像其他语言那样
    在标准库中内建 mock 对象功能, 不过我们确实可以创建一个与 mock 对象有着相同功
    能的结构体. 


** RefCell<T> 在运行时记录借用
   当创建可变和不可变引用时, 我们分别使用 ~&~ 和 ~&mut~ 语法. 对于 ~RefCell<T>~
   来说, 则是 ~borrow~ 和 ~borrow_mut~ 方法, 这属于 ~RefCell<T>~ 安全 API 的一部
   分. ~borrow~ 方法返回 ~Ref<T>~ 类型的智能指针, ~borrow_mut~ 方法返回 ~RefMut~
   类型的智能指针. 这两个类型都实现了 ~Deref~, 所以可以当做常规引用对待.

   ~RefCell<T>~ 记录当前有多少个活动的 ~Ref<T>~ 和 ~RefMut<T>~ 智能指针. 每次调
   用 ~borrow~, ~RefCell<T>~ 将活动的不可变借用计数加一. 当 ~Ref<T>~ 离开作用域
   时, 不可变借用计数减一. 就像编译时借用规则一样, ~RefCell<T>~ 在任何时候只允许
   有多个不可变借用或一个可变借用.

** 结合 Rc<T> 和 RefCell<T> 来拥有多个可变数据的所有者
   ~RefCell<T>~ 的一个常见用法是与 ~Rc<T>~ 结合. ~Rc<T>~ 允许对相同数据有多个所
   有者, 不过只能提供数据的不可变访问. 如果有一个储存了 ~RefCell<T>~ 的 ~Rc<T>~
   的话, 就可以得到有多个所有者 *并且* 可以修改的值了.

   

