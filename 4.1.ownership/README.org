* 所有权
  Rust核心功能之一: *所有权(ownership)*.

  Rust通过所有权系统管理内存, 编译器在编译时会根据一系列的规则进行检查. 在运行时,
  所有权系统的任何功能都不会减慢程序

** 栈(Stack)和堆(Heap)
   栈和堆都是代码在 *运行时可供使用* 的内存, 但是它们的结构不同. 栈以顺序存储值
   并以相反顺序取出值.

   栈中的所有数据都必须占用已知且固定的大小. 在编译时大小未知或大小可能变化的数
   据, 要改为存储在堆上. 堆是缺乏组织的: 当向堆放入数据时, 要请求一定大小的空间.
   操作系统在堆的某处找到一个足够大的空位, 把它作为标记已使用, 并返回一个表示该
   位置的 *指针*. 这个过程称作 *在堆上分配内存(allocating on the heap)*. 有时简
   称 "分配(allocating)". 将数据推入栈中并不认为是分配. 因为指针的大小是已知且固
   定的,可以将指针存储在栈上, 不过当需要实际数据时, *必须访问指针*.

   *入栈比在堆上分配内存要快*, 因为(入栈时)操作系统无需为存储新数据去搜索内存空
    间; 其位置总是在栈顶. 相比之下, 在堆上分配内存则需要更多的工作, 这是因为操作
    系统必须首先找到一块足够存放数据的内存空间, 并接着做一些记录为下一次分配做准
    备.

   *访问堆上的数据比访问栈上的数据慢*, 因为必须通过指针来访问. 现代处理器在内存
    中 *跳转越少越快(缓存)*. eg: 顺序处理 vs 乱序处理. 同样原因, 处理器在处理的
    数据彼此较近的时候(eg: 在栈上) 比较远的时候(eg: 可能在堆上)能更好的工作. 在
    堆上分配大量的空间也可能消耗时间

    当代码调用一个函数时, 传递给函数的值(包括可能指向堆上数据的指针) 和函数的局
    部变量 *被压入栈中*. 当函数结束时, 这些值被移除栈.

    跟踪哪部分代码正在使用堆上的哪些数据, 最大限度的减少堆上的重复数据的数量, 以
    及清理堆上不再使用的数据确保不会耗尽空间, 这些问题正是 *所有权系统需要处理的*.

    一旦立即了所有权, 就不需要经常考虑栈和堆了, 明白了所有权的存在就是为了 *管理
    堆数据*, 能够帮助解释为什么所有权要以这种方式工作.

** 所有权规则
   1. Rust 中的每一个值都有一个被称为其 *所有者(owner)* 的变量.
   2. 值在任一时刻有且只有一个所有者
   3. 当所有者(变量)离开作用域, 这个值将被丢弃

** String类型
*** 内存与分配
    字符串字面值在编译时就知道其内容, 所以文本被直接 *硬编码* 进最终的可执行文件
    中. 这使得字符串字面量快速且高效.

    对于 ~String~ 类型, 为了支持一个可变, 可增长的文本片段, 需要在堆上分配一块编
    译时位置大小的内存来存放内容. 这意味着:
    1. 必须在运行时向操作系统请求内存
       当调用 ~String::from~ 时, 它的实现(implementation)请求所需的内存
    2. 需要一个当我们处理完 ~String~ 时将内存返回给操作系统的方法.
       在有 GC(garbage collector) 的语言中, GC记录并清除不再使用的内存, 而我们并
       不需要关心它. 没有 GC 的话, 需要识别出不再使用的内存并调试代码显式释放.

       Rust采取了一个不同的策略: 内存在 *拥有它的变量离开作用域后就被自动释放*.
       即为 ~drop~ 函数
       #+begin_src rust
         {
             let s = String::from("hello"); // 此时起, s有效
         }
         // s不再有效, 自动释放
       #+end_src
       
       *注意*: 在 C++ 中, 这种 item(项) 在生命周期时释放自动的模式有时被称作 *资
       源获取即初始化(Resource Acquisition is Initialization(RAII))*. 不过在更复
       杂的场景下代码的行为可能是 *不可预测* 的, eg: 当有多个变量使用再堆上分配
       内存时
*** 变量与数据交互的方式(一): 移动
    #+begin_src rust
      let s1 = String::from("hello");
      let s2 = s1;
    #+end_src

    ~String~ 由 3 部分组成: 一个指向存放字符串内容的指针, 一个长度, 和一个容量.
    这一组数据存储在 *栈* 上. 另一端存放内容的内存部分.

    长度(len): 使用了多少节的内存
    容量(capacity): 从操作系统共获取了多少字节的内存

    当 ~s1~ 赋值给 ~s2~, ~String~ 的数据被赋值了, 这意味着我们从栈上拷贝了它的指
    针, 长度和容量. *并没有复制指针指向的堆上数据*.

    当变量离开作用域后, ~Rust~ 自动调用 ~drop~ 函数并清理变量的堆内存. 但是此时
    ~s2~ 与 ~s1~ 指向了 *同一位置*. 当都离开作用域时, 它们都会尝试释放相同的内存.
    这是一个叫做 *二次释放(double free)* 的错误, 也是内存安全性 BUG 之一. 两次释
    放(相同)的内存会导致内存污染, 它可能会导致潜在的安全漏洞.

    为了确保内存安全, 这种场景下 Rust 的处理为: 认为 ~s1~ *不再有效*, 因此 Rust
    不需要在 ~s1~ 离开作用域后清理任何东西.

    这种行为不同于 *浅拷贝(shallow copy)* 和 *深拷贝(deep copy)*, 称为 *移动
    (move)*

    这样 *解决了内存释放的问题*.

    Tips: Rust *永远也不会* 自动创建数据的 "深拷贝". 因此, 任何 *自动* 的复制可
    以被认为对运行时性能影响较小.
*** 变量与数据的交互方式(二): 克隆
    若 *确实* 需要深度复制 ~String~ 中 *堆上的数据*, 而不仅仅是栈上的数据, 可以
    使用通用函数 ~clone~.
    #+begin_src rust
      let s1 = String::from("hello");
      let s2 = s1.clone();

      println!("s1 = {}, s2 = {}", s1, s2);
    #+end_src

*** 只在栈上的数据: 拷贝
    #+begin_src rust
      let x = 5;
      let y = x;

      println!("x = {}, y = {}", x, y);
    #+end_src

    栈拷贝值是快速的. 没有理由让 ~x~ 失效.

    Rust 有一个 ~Copy~ trait 的特殊注解, 可以用在类似整型这样的存储在栈上的类型
    上(第十章). 如果一个类型拥有 ~Copy~ trait, 一个旧的变量在将其赋值给其他变量
    后 *仍然可用*. Rust *不允许* 自身或其任何部分实现了 ~Drop~ trait 的类型使用
    ~Copy~ trait. 如果对其值离开作用域时需要特殊处理的类型使用 ~Copy~ 注解. 将会
    出现一个编译时错误.

    可 ~Copy~ 的类型: 任何简单标量值的组合可以是 ~Copy~ 的, 不需要分配内存或某种
    形式资源的类型是 ~Copy~ 的:
    - 所有整数类型, eg: ~u32~
    - 布尔类型: ~bool~
    - 所有浮点, eg: ~f64~
    - 字符类型: ~char~
    - 元组, 当且仅当其包含的类型也是 ~Copy~ 的时候
      eg: ~(i32, i32)~ 可以, ~(i32, String)~ 不行
   
