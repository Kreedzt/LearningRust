* 共享状态并发
  虽然消息传递是一个很好的处理并发的方式, 但并不是唯一一个.
  Go 编程语言文档中口号的一部分:
  "不要通过共享内存来通讯"

  在某种程度上, 任何编程语言中的通道都类似于单所有权, 因为一旦将一个值传送到通道
  中, 将无法再使用这个值. 共享内存类似于多所有权: 多个线程可以同时访问相同的内存
  位置. 然而这会增加额外复杂性, 因为需要以某种方式管理这些不同的所有者.

** 互斥器一次只允许一个线程访问数据
   *互斥器(mutex)* 是 mutual exclusion 的缩写, 任意时刻, 其只允许一个线程访问某
   些数据. 为了访问互斥器中的数据, 线程首先需要通过互斥器的 *锁(lock)* 来表明其
   希望访问数据. 锁是一个作为互斥器一部分的数据结构, 它记录谁有数据的排他访问权.
   因此, 我们描述互斥器为锁系统 *保护(guarding)* 其数据.

   使用时不得不记住:
   1. 在使用数据之前尝试获取锁
   2. 处理完被互斥器所保护的数据之后, 必须解锁数据, 这样其他线程才能够获取锁.

      
   是哟你关联函数 ~new~ 创建一个 ~Mutex<T>~. 使用 ~lock~ 获取锁, 以访问互斥器中
   的数据. 这个调用会阻塞当前线程, 直到我们拥有锁为止.

   如果另一个线程拥有锁, 并且那个线程 panic 了, ~lock~ 调用会失败. 这种情况下, 
   *没人能够再获取锁*. 可选 ~unwrap~ 并在遇到这种情况时使线程 panic.

   一旦货去了锁, 就可以将返回值视为一个其内部数据的可变引用. 

   ~Mutex<T>~ 是一个智能指针. ~lock~ 调用 *返回* 一个叫做 ~MutexGuard~ 的智能指
   针. 这个智能指针实现了 ~Deref~ 来指向其内部数据; 其也提供了一个 ~Drop~ 实现当
   ~MutexGuard~ 离开作用域时 *自动释放锁*. 

** 原子引用计数 Arc<T>
   ~Arc<T>~ 是一个类似 ~Rc<T>~ 并可以 *安全的用于并发* 环境的类型. "a" 代表 *原
   子性* (atomic). 撕破这是 uoge *原子引用计数(atomically reference counted)* 类
   型. 工作起来类似原始类型, 不过可以安全的在线程间共享.

   
** RefCell<T> / Rc<T> 与 Mutex<T>/Arc<T> 的相似性
   因为 ~counter~ 是不可变的, 不过可以获取其内部值得可变引用; 这意味着
   ~Mutex<T>~ 提供了内部可变性, 类似 ~Cell~ 系列类型. 可以像 ~RefCell<T>~ 可以改
   变 ~Rc<T>~ 中的内容那样, 同样可以用 ~Mutex<T>~ 来改变 ~Arc<T>~ 中的内容.

   Rust 不能避免使用 ~Mutex<T>~ 的全部逻辑错误. 使用 ~Rc<T>~ 就有造成引用循环的
   风险. 这时两个 ~Rc<T>~ 值相互引用, 会造成内存泄漏. ~Mutex<T>~ 也有造成 *死锁*
   的风险(deadlock). 这发生于当一个操作需要锁住两个资源而两个线程各持一个锁, 这
   会造成它们永远相互等待.
