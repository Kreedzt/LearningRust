* 面向对象语言的特征
** 对象包含数据和行为
   定义: 面向对象的程序是由对象组成的. 一个 *对象* 包含数据核操作这些数据的过程.
   这些过程被称为 *方法* 或 *操作*.

   在这个定义下, Rust 是面向对象的: 结构体和枚举包含数据而 ~impl~ 块提供了在结构
   体和枚举之上的方法. 虽然带有方法的结构体和枚举并不被 *称为* 对象, 但是他们提
   供了与对象相同的功能, 参考 <<The Gang of Four>> 中对象的定义.

** 封装隐藏了实现细节
   另一个通用与面向对象编程相关的方面是 *封装(encapsulation)* 的思想: 对象的实现
   细节不能被使用对象的代码获取到. 所以唯一与对象交互的方式是通过对象提供的公有
   API, 使用对象的代码无法深入到对象内部并直接改变数据或者行为. 封装使得改变和重
   构对象的内部时无需改变使用对象的代码.

   可以使用 ~pub~ 关键字来决定模块, 类型, 函数和方法是公有的, 而默认情况下其他一
   切都是私有的.

** 继承, 作为类型系统与代码共享
   *继承(inheritance)* 是一个很多编程语言都提供的机制, 一个对象可以定义为继承另
    一个对象的定义, 这使其可以获得父对象的数据和行为, 而无需重新定义.
   
   如果一个语言必须有继承才能被称为面向对象语言的话, 那么 Rust 就不许面向对象的.
   无法定义一个结构体继承父结构体的成员和方法. 然而, 如果过去常常在编程工具箱使
   用继承, 根据最初考虑继承的原因, Rust 也提供了其他的解决方案.

   选择继承的主要原因: 第一个是为了重用代码: 一旦为一个类型实现了特定行为, 继承
   可以对一个不同的类型重用这个实现. 相反 Rust 代码可以使用默认 trait 方法实现来
   进行共享. 第二个使用继承的原因与类型系统有关: 表现为子类型可以用于父类型被使
   用的地方. 这也被称为 *多态(polymorphism)*, 这意味着如果多种对象共享特定的属性,
   则可以相互替代使用.

   多态: 对于继承来说, 这些类型通常是子类. Rust 则通过泛型来对不同的可能类型进行
   抽象, 并通过 trait bounds 对这些类型所必须提供的内容施加约束. 这有时被称为
   bounded parametric polymorphism.

   近年来继承作为一种语言设计的解决方案在很多语言失宠, 因为其时常带有共享多余所
   需的代码的风险. 子类不应总数共享其父类的所有特征, 但是继承却始终如此. 如此会
   使程序设计更为不灵活, 并引入无意义的子类方法调用.或由于方法实际并不适用于子类
   而造成错误的可能性. 某些语言还只允许子类继承一个父类, 进一步限制了程序设计的
   灵活性.

   因此, Rust 使用 trait 对象而不是继承.
