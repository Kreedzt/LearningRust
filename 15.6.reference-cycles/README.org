* 引用循环与内存泄漏
  Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存(被称为 *内存泄
  漏* (memory leak)), 但并不是不可能, 与在编译时拒绝的数据竞争不同, Rust 并不保
  证完全地避免内存泄漏, 这意味着内存泄漏在 Rust 被认为是内存安全的. 这一带你可以
  通过 ~Rc<T>~ 和 ~RefCell<T>~ 看出: 创建引用循环的可能性是存在的. 这回造成内存
  泄漏, 因为每一项的引用计数永远也到不了 0, 其值永远不会被丢弃.

** 制造引用循环
   如果有包含 ~Rc<T>~ 的 ~RefCell<T>~ 值或类似的嵌套结合了内部可变性和引用计数类
   型, 务必小心确保没有形成一个引用循环; 无法指望 Rust 捕获它们. 创建引用循环是
   一个程序上的逻辑 bug, 应该使用自动化测试, 代码评审和其他软件开发最佳实践来使
   其最小化.

   另一个解决方案是重新组织数据结构, 使得一部分引用拥有所有权而另一部分没有. 换
   句话说, 循环将由一些拥有所有权的关系和一些无所有权的关系组成, 只有所有权关系
   才能影响值是否可以被丢弃.

** 避免引用循环: 将 Rc<T> 变为 Weak<T>
   可以通过调用 ~Rc::downgrade~ 并传递 ~Rc<T>~ 实例的引用来创建其值的 *弱引用*
   (weak reference). 调用 ~Rc::downgrade~ 时会得到 ~Weak<T>~ 类型的智能指针. 不
   同于将 ~Rc<T>~ 实例的 ~strong_count~ 加一, 调用 ~Rc::downgrade~ 会将
   ~weak_count~ 加一.
   
   ~Rc<T>~ 类型使用 ~weak_count~ 来记录其存在多少个 ~Weak<T>~ 引用, 类似于
   ~strong_count~. 其区别在于 ~weak_count~ 无需计数为 0 就能使 ~Rc<T>~ 实例被清
   理.

   强引用代表如何共享 ~Rc<T>~ 实例的所有权, 但弱引用并不属于所有权关系. 他们不会
   造成引用循环, 因为任何弱引用的循环会在其相关的强引用计数为 0 时被打断.

   因为 ~Weak<T>~ 引用的值可能已经被丢弃了, 为了使用 ~Weak<T>~ 所指向的值, 我们
   必须确保其值仍然有效. 为此可以调用 ~Weak<T>~ 实例的 ~upgrade~ 方法, 这会返回
   ~Option<Rc<T>>~. 如果 ~Rc<T>~ 的值还未被丢弃, 则结果是 ~Some~; 如果 ~Rc<T>~
   已被丢弃, 则结果是 ~None~. 因为 ~upgrade~ 返回一个 ~Option<T>~, 我们确信 Rust
   会处理 ~Some~ 和 ~None~ 的情况, 所以它不会返回非法指针.

   我们会创建一个某项知道其子项 *和* 父项的树形结构的例子, 而不是只知道下一项的
   列表.
