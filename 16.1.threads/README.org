* 使用线程同时运行代码
  在大部分现代操作系统中, 已执行程序的代码在一个 *进程(process)* 中运行, 操作系
  统则负责管理多个进程. 在程序内部, 也可以拥有多个同时运行的独立部分. 运行这些独
  立部分的功能被称为线程(threads).

  将程序中的计算拆分进多个线程可以改善性能, 因为程序可以同时运行多个任务, 不过这
  也会增加复杂性. 因为线程是同时运行的, 所以无法预先保证不同线程中的代码的执行顺
  序. 这回导致诸如此类问题:
  
  - 竞争状态(Race conditions): 多个线程以不一致的顺序访问数据或资源
  - 死锁(Deadlocks), 两个线程相互等待对方停止使用其所拥有的资源, 这会阻止它们继
    续运行
  - 只会发生在特定情况且难以稳定重现和修复的 bug

  编程语言有一些不同的方法来实现线程. 很多操作系统提供了创建新线程的 API  . 这种
  由操作系统 API 创建线程的模型有时被称为 1:1, 一个 OS 线程对应一个语言线程.

  很多编程语言提供了自己特殊的线程实现. 编程语言提供的线程被称为 *绿色(green)*
  线程, 使用绿色线程的语言会在不同数量的 OS 线程的上下文中执行它们. 为此, 绿色线
  程模式被称为 M:N 模型: ~M~ 个绿色线程对应 ~N~ 个 OS 线程, 这里 ~M~ 和 ~N~ 不必
  相同.

  每一个模型都有其优势和取舍. 对于 Rust 来说最重要的取舍是运行时支持.

  在当前上下文中, *运行时* 代表二进制文件中包含的由语言自身提供的代码. 这些代码
  根据语言的不同可大可小, 不过任何非汇编语言都会有一定数量的运行时代码. Rust 需
  要做到几乎没有运行时, 同时保持高性能必须能够调用 C 语言.

  绿色线程的 M:N 模型需要更大的语言运行时来管理这些线程. 因此, Rust 标准库只提供
  了 1:1 线程模型实现.

** 使用 spawn 创建新线程
   
