* 智能指针
  *指针(pointer)* 是一个包含内存地址的变量的通用概念. 这个地址引用, 或 "指向
   "(points at) 一些其他数据, Rust 中最常见的指针是 *引用(reference)*. 引用以
   ~&~ 符号为标志并借用了他们所指向的值. 除了引用数据没有任何其他特殊功能. 他们
   也没有额外开销, 所以引用的最多.

   另一方面, *智能指针(smart pointers)* 是一类 *数据结构*, 他们的表现类似指针,
   但是也有额外的元数据和功能. 智能指针的概念并不为 Rust 所独有; 起源于 C++ 并存
   在于其他语言中. Rust 标准库中不同的智能指针提供了无多余引用的额外功能. 本章将
   会探索的一个例子便是 *引用计数(reference counting)* 智能指针类型, 其允许数据
   有多个所有者. 引用计数只能指针记录总共有多少个所有者, 并当没有任何所有者时负
   责清理数据.

   在 Rust 中, 普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针;
   相反, 在大部分情况下, 智能指针 *拥有* 他们指向的数据
   
   ~String~ 和 ~Vec<T>~ 也是智能指针. 它们拥有一些数据并允许修改. 也带有元数据
   (eg: 容量)和额外的功能或保证(~String~ 的数据总是有效的 UTF-8 编码)

   智能指针通常使用结构体实现. 智能指针区别于常规结构体的显著特性在于其实现了
   ~Deref~ 和 ~Drop~ trait. ~Deref~ trait 允许智能指针结构体实例表现的像引用一样,
   这样就可以编写既用于引用, 又用于智能指针的代码. ~Drop~ trait 允许我们自定义当
   智能指针离开作用域时运行的代码.

   考虑到只能指针是一个在 Rust 经常被使用的通用设计模式, 如下问常用的标准库的内
   容:

   - ~Box<T>~: 用于在堆上分配值
   - ~Rc<T>~: 一个引用计数类型, 其数据可以有多个所有者
   - ~Ref<T>~ 和 ~RefMut<T>~, 通过 ~RefCell<T>~ 访问. (~RefCell<T>~ 是一个在运行
     时而不是在编译时执行借用规则的类型).

     
   另外会涉及 *内部可用性(interior mutability)* 模式, 这是不可变类型暴露出改变其
   内部值得 API. 也会讨论 *引用循环(reference cycles)* 会如何泄漏内存, 以及如何
   避免
