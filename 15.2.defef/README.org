* 通过 Deref trait 将智能指针当做常规引用处理
  实现 ~Deref~ trait 允许我们重载 *解引用运算符(derefermce operator)* ~*~. 通过
  这种方式实现 ~Deref~ trait 的智能指针可以被当做常规引用来对待, 可以编写操作引
  用的代码并用于智能指针.

  首先看解引用运算符如何处理常规引用, 接着尝试定义我们自己的类似 ~Box<T>~ 的类型
  并看看为何解引用运算符不能像引用一样工作. 我们会探索如何实现 ~Deref~ trait 使
  得智能指针以类似引用的方式工作变为可能. 最后, 会讨论 Rust 的 *解引用强制多态*
  (deref coercions) 功能以及它是如何处理引用或智能指针的.

  
** 通过实现 Deref trait 将某类型像引用一样处理
   标准库提供 ~Deref~ trait, 要求实现名为 ~deref~ 的方法. 其借用 ~self~ 并返回一
   个内部数据的引用

   没有 ~Deref~ trait 的话, 编译器只会解引用 ~&~ 引用类型. ~deref~ 方法向编译器
   提供了获取任何实现了 ~Deref~ trait 的类型的值, 并且调用这个类型的 ~deref~ 方
   法来获取一个它知道如何解引用的 ~&~ 引用的能力

   当输入 ~*y~ 时, Rust 事实上在底层运行了如下代码:
   #+begin_src rust
     *(y.deref())
   #+end_src

   Rust 将 ~*~ 运算符替换为先调用 ~deref~ 方法再进行普通解引用的操作, 如此我们便
   不用担心是否还需手动调用 ~deref~ 方法. 该特性可以让我们写出行为一致的代码, 无
   论是面对的常规引用还是实现了 ~Deref~ 的类型.

   ~deref~ 方法返回值的引用, 以及 ~*(y.deref())~ 括号外边的普通解引用仍为必须的
   原因在于所有权. 如果 ~deref~ 方法直接返回值而不是引用, 其值(的所有权)将被移
   出 ~self~. 在这里以及大部分解引用运算符的情况下我们并不希望获取内部值得所有权.

   *注意*: 每当在代码中使用 ~*~ 时, ~*~ 运算符都被替换成了先调用 ~deref~ 方法再
    接着使用 ~*~ 解引用的操作, 且只会发生一次, 不会对 ~*~ 操作符无限递归替换.

** 函数和方法的隐式解引用强制多态

   *解引用强制多态(deref coercions)* 是 Rust 在函数或方法传参上的一种便利. 其将
    实现了 ~Deref~ 的类型的引用转换为原始类型通过 ~Deref~ 所能够转换的类型的引用.

   当这种特定类型的引用作为实参专递给和形参类型不同的函数或方法时, 解引用强制多
   态将自动发生. 这时会有 *一系列* 的 ~deref~ 方法被调用, 把我们提供的类型转换成
   了参数所需的类型.

   解引用强制多态的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用
   ~&~ 和 ~*~ 的引用和解引用. 这个功能也使得我们可以编写更多同时作用域引用或智能
   指针的代码.

   
** 解引用强制多态如何与可变性交互
   类似于如何 ~Deref~ trait 重载不可变的 ~*~ 运算符, Rust 提供了 ~DerefMut~
   trait 用于重载可变引用的 ~*~ 运算符.

   Rust 在发现类型 trait 实现满足三种情况时会进行解引用强制多态:
   
   1) 当 ~T: Deref<Target = U>~ 时从 ~&T~ 到 ~&U~.
   2) 当 ~T: DerefMut<Target = U>~ 时从 ~&mut T~ 到 ~&mut U~.
   3) 当 ~T: Deref<Target = U>~ 时从 ~&mut T~ 到 ~&U~.
      
   第三种情况下, Rust 会将可变引用转为不可变引用. 但是反之是 *不可能* 的.
