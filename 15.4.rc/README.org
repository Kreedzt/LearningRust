* RC<T> 引用计数智能指针
  大部分情况下所有权是非常明确的: 可以准确地知道哪个变量拥有某个值. 然而, 有些情
  况单个值可能会有 *多个所有者*. eg: 在图数据结构中, 多个边可能指向相同的点. 而
  这个点从概念上讲为所有指向它的边所拥有. 节点直到没有任何边指向它之前都不应该被
  清理.

  为了启用多所有权, Rust 有 ~Rc<T>~ 类型, 名称为 *引用计数(reference counting)*
  的缩写. 引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用. 如果某个
  值有 0 个引用, 就代表没有任何有效引用并可以被清理.

  ~Rc<T>~ 用于当我们希望在堆上分配一些内存程序的多个部分读取, 而且无法在编译时
  确定程序的哪一部分会最后结束使用它的时候. 如果确实知道哪部分是最后一个结束使用
  的话, 就可以令其成为数据的所有者, 正常的所有权规则就可以在编译时生效.

  *注意*: ~Rc<T>~ 只能用于单线程场景; 第十六章会涉及到如何在多线程程序中引用计数.

** 克隆 Rc<T> 会增加计数
   
   在程序中每个引用计数变化的点, 会打印出引用计数, 其值可以通过调用
   ~Rc::string_count~ 函数获得, 还有另一个函数名为 ~weak_count~, 在避免引用循环
   章会讲解用途.

   当清理完所有引用时, 计数会清零, 同时 ~Rc<List>~ 被 完全清理. 使用 ~Rc<T>~ 允
   许一个值拥有多个所有者, 引用计数规则确保只要任何所有者依然存在其值也保持有效.

   通过不可变引用, ~Rc<T>~ 允许在程序的多个部分之间只读地共享数据, 如果 ~Rc<T>~
   也允许多个可变引用, 则会违反借用规则. 下一部分会讨论内部可变性模式和
   ~RefCell<T>~ 类型, 可以与 ~Rc<T>~ 结合使用来处理不可变性的限制.
