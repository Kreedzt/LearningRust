* 闭包: 可以捕获环境的匿名函数
  Rust 的 *闭包(closures)* 是可以保存进变量或作为参数传递给其他函数的匿名函数.
  可以在一个地方创建闭包, 然后在不同的上下文中执行闭包运算. 不停与函数, 闭包允许
  捕获调用者作用域中的值. 我们将展示闭包的这些功能如何复用代码和自定义行为.
 
** 闭包类型推断和注解
   多种语法格式:
   #+begin_src rust
     fn add_one_v1 (x: u32) -> u32 { x + 1};
     let add_one_v2 = |x: u32| -> u32 { x + 1 };
     let add_one_v3 = |x| { x + 1 };
     let add_one_v4 = |x| x + 1;
   #+end_src

** 使用带有泛型和 Fn trait 的闭包
   可以创建一个存放闭包和调用闭包结果的结构体. 该结构体只会在需要结果时执行闭包,
   并会缓存结果只, 这样余下的代码就不必再负责保存结果并可以复用该值. 你可能见过
   这种模式被称 memoization 或 lazy evaluation(惰性求值).

   为了让结构体存放闭包, 我们需要指定闭包的类型, 因为结构体定义需要知道其每一个
   字段的类型. 每一个闭包实例有其自己独有的匿名类型: 即使两个闭包有相同的签名,
   它们的类型 *仍然可以被认为是不同*. 为了定义使用闭包的及饿哦固体, 枚举或函数参
   数, 需要使用泛型和 trait bound.

   ~Fn~ 系列 trait 由标准库提供. 所有的闭包都实现了 trait ~Fn~, ~FnMut~ 或
   ~FnOnce~ 中的一个. 在 "闭包会捕获其环境" 部分会讨论这些区别.

   *注意*: 函数也都实现了这三个 ~Fn~ trait. 如果不需要捕获环境中的值, 则可以使用
    实现了 ~Fn~ trait的函数而不是闭包.

** 闭包会捕获其环境
   当闭包从环境中捕获一个值, 闭包会载闭包体中储存这个值以供使用. 这回使用内存并
   产生额外的开销, 在更一般的场景中, 当我们不需要闭包来捕获环境时, 我们不希望产
   生这些开销. 因为函数从未允许捕获环境, 定义和使用函数也就从不会有这些额外开销.

   闭包可以通过三种方式捕获其环境, 他们直接对应函数的三种获取参数的方式: 获取所
   有权, 可变借用和不可变借用. 这三种捕获值的方式被编码为如下三个 ~Fn~ trait:
   
   - ~FnOnce~ 消费从周围作用域捕获的变量, 闭包周围的作用域被称为其 *环境*,
     environment. 为了消费捕获到的变量, 闭包必须获取其所有权并在定义闭包时将其移
     动进闭包. 其名称的 ~Once~ 部分代表了闭包不能多次获取相同变量的所有权的事实,
     所以它只能被调用一次.
   - ~FnMut~ 获取可变的借用值所以可以改变其环境
   - ~Fn~ 从其环境获取不可变的借用值

     
   当创建一个闭包时, Rust 根据其如何使用环境中变量来推断我们希望如何引用环境. 由
   于所有闭包都可以被调用至少一次, 所以所有闭包都实现了 ~FnOnce~. 那些并没有移动
   被不会变量的所有权到闭包内的闭包也实现了 ~FnMut~, 而不需要对被捕获的变量进行
   可变访问的闭包则也实现了 ~Fn~

   如果希望强制闭包获取其使用的环境值的所有权, 可以在参数列表前使用 ~move~ 关键
   字. 这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用.

   大部分需要指定一个 ~Fn~ 系列 trait bound 的时候, 可以从 ~Fn~ 开始, 而编译器会
   根据闭包体重的情况告诉是否需要 ~FnMut~ 或 ~FnOnce~.
