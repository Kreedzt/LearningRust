* 面向对象设计模式的实现
  *状态模式(state pattern)* 是一个面向对象设计模式. 该模式的关键在于一个值有某些
   内部状态, 体现为一系列的状态对象, 同时值的行为随着其内部状态而改变. 状态对象
   共享功能: 当然, 在 Rust 中使用结构体和 trait 而不是对象和继承. 每一个状态对象
   负责其自身的行为, 以及该状态何时应当转移至另一个状态. 持有一个状态对象的值对
   于不同状态的行为以及状态转移毫不知情.

   使用状态模式意味着当程序的业务需求改变时, 无需改变值持有状态或者使用值的代码.
   我们只需更新某个状态对象中的代码来改变其规则, 或者是增加更多的状态对象.
 
** 状态模式的权衡取舍
   对于状态模式来说, ~Post~ 的方法和使用 ~Post~ 的位置无需 ~match~ 语句, 同时增
   加新状态只涉及到增加一个新 ~struct~ 和为其实现 trait 的方法.

   状态模式的一个缺点是因为状态实现了状态之间的转换, 一些状态会相互联系. 如果在
   ~PendingReview~ 和 ~Published~ 之间增加另一个状态, 比如 ~Scheduled~, 则不得不
   修改 ~PendingReview~ 中的代码来转移到 ~Scheduled~. 如果 ~PendingReview~ 无需
   新增的状态而改变就好了, 不过这意味着切换到另一种设计模式.

   完全按照面向对象语言的定义实现这个模式并没有尽可能地利用 Rust 的优势.

** 将状态和行为编码为类型
   不同于完全封装状态和状态转移使得外部代码对齐毫不知情, 我们将状态编码进不同的
   类型, 如此, Rust 的类型检查就会将任何在只能使用发布博文的地方使用草案博文的尝
   试变为编译时错误.

** 实现状态转移为不同类型的转换
   即使 Rust 能够实现面向对象模式, 也有其他像状态编码进类型这样的模式存在. 这些
   模式有着不同的权衡取舍. 重新思考这些问题来利用 Rust 提供的像在编译时避免一些
   bug 这样的有益功能. 在 Rust 中面向对象模式并不总数最好的解决方案, 因为 Rust
   拥有像所有权这样的面向对象语言所没有的功能.

   
