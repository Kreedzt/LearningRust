* 一个 I/O 项目: 构建命令行程序
** 接受命令行参数
*** 读取参数值
**** args 函数和无效的 Unicode
      注意 ~std::env::args~ 在其任何参数包含 *无效 Unicode* 字符时会 panic. 如果
      需要接受包含无效 Unicode 字符的参数, 使用 ~std::env::args_os~ 代替. 这个函
      数返回 ~Osstring~ 值而不是 ~String~ 值. ~OsString~ 值每个平台都不一样, 而且
      比 ~String~ 值处理起来复杂.

** 重构以改进模块化与错误处理
*** 二进制项目的关注分离
    ~main~ 函数负责多个任务的组织问题在许多二进制项目中很常见. 所以 Rust 社区开
    发出一类在 ~main~ 函数开始变得庞大时二进制程序的关注分离的指导性过程. 有如下
    步骤:
    
    - 将程序拆分成 ~main.rs~ 和 ~lib.rs~ 并将程序的逻辑放入 ~lib.rs~ 中
    - 当命令行解析逻辑比较小时, 可以保留在 ~main.rs~ 中.
    - 当命令行解析开始变得复杂时, 也同样将其从 ~main.rs~ 提取到 ~lib.rs~ 中

    经过这些过程之后保留在 ~main~ 函数中的责任应该被限制为:
    - 使用参数值调用命令行解析逻辑
    - 设置任何其他的配置
    - 调用 ~lib.rs~ 中的 ~run~ 函数
    - 如果 ~run~ 返回错误, 则处理这个错误


    关注分离: ~main.rs~ 处理程序运行, 而 ~lib.rs~ 处理所有真正的任务逻辑. 因为不
    能直接测试 ~main~ 函数, 这个结构通过将所有的程序逻辑移动到 ~lib.rs~ 的函数中
    使得我们可以测试他们. 仅保留在 ~main.rs~ 中的代码将足够小以便阅读就可以验证
    其正确性.

*** 组合配置值
    *注意*: 一些同学将这种在复杂类型更为合适的场景下使用基本类型的反模式称为 *基
    本类型偏执(primitive obsession)*.

    *使用 ~clone~ 的权衡取舍*:
    由于其运行时消耗, 许多 Rustacean 之间有一个趋势是倾向于避免使用 ~clone~ 来解
    决所有权问题. 在关于迭代器的第十三章中, 将会学习如何更有效率的处理这种情况.

*** 从 run 函数返回错误
    通过将剩余的逻辑分离进 ~run~ 函数而不是留在 ~main~ 中, 就可以不再通过
    ~expect~ 允许程序 panic, ~run~ 函数将会在出错时返回一个 ~Result<T, E>~. 这让
    我们进一步以一种对用户友好的方式统一 ~main~ 中的错误处理.

    对于错误类型, 使用了 *trait 对象 ~Box<dyn Error>~ (使用 ~std::error::Error~
    引入作用域)*. 十七章涉及 trait 对象, 目前只需知道 ~Box<dyn Error>~ 意味着函
    数会返回实现了 ~Error~ trait 的类型, 不过无需指定具体会返回的值的类型. 这提
    供了在不同错误场景可能有不同类型的错误返回值的灵活性. 也就是 ~dyn~, 是动态
    (dynamic) 的缩写.

    使用 ~?~ 可以从函数中返回错误值让调用者处理

    成功时返回 ~Ok~ 值, 因为 ~run~ 函数签名的成功返回类型是 ~()~ 意味着需要将
    unit 类型值包装进 ~Ok~ 值中
