* 一个 I/O 项目: 构建命令行程序
** 接受命令行参数
*** 读取参数值
**** args 函数和无效的 Unicode
      注意 ~std::env::args~ 在其任何参数包含 *无效 Unicode* 字符时会 panic. 如果
      需要接受包含无效 Unicode 字符的参数, 使用 ~std::env::args_os~ 代替. 这个函
      数返回 ~Osstring~ 值而不是 ~String~ 值. ~OsString~ 值每个平台都不一样, 而且
      比 ~String~ 值处理起来复杂.

** 重构以改进模块化与错误处理
*** 二进制项目的关注分离
    ~main~ 函数负责多个任务的组织问题在许多二进制项目中很常见. 所以 Rust 社区开
    发出一类在 ~main~ 函数开始变得庞大时二进制程序的关注分离的指导性过程. 有如下
    步骤:
    
    - 将程序拆分成 ~main.rs~ 和 ~lib.rs~ 并将程序的逻辑放入 ~lib.rs~ 中
    - 当命令行解析逻辑比较小时, 可以保留在 ~main.rs~ 中.
    - 当命令行解析开始变得复杂时, 也同样将其从 ~main.rs~ 提取到 ~lib.rs~ 中

    经过这些过程之后保留在 ~main~ 函数中的责任应该被限制为:
    - 使用参数值调用命令行解析逻辑
    - 设置任何其他的配置
    - 调用 ~lib.rs~ 中的 ~run~ 函数
    - 如果 ~run~ 返回错误, 则处理这个错误


    关注分离: ~main.rs~ 处理程序运行, 而 ~lib.rs~ 处理所有真正的任务逻辑. 因为不
    能直接测试 ~main~ 函数, 这个结构通过将所有的程序逻辑移动到 ~lib.rs~ 的函数中
    使得我们可以测试他们. 仅保留在 ~main.rs~ 中的代码将足够小以便阅读就可以验证
    其正确性.

*** 组合配置值
    *注意*: 一些同学将这种在复杂类型更为合适的场景下使用基本类型的反模式称为 *基
    本类型偏执(primitive obsession)*.

    *使用 ~clone~ 的权衡取舍*:
    由于其运行时消耗, 许多 Rustacean 之间有一个趋势是倾向于避免使用 ~clone~ 来解
    决所有权问题. 在关于迭代器的第十三章中, 将会学习如何更有效率的处理这种
