* 生命周期与引用有效性
** 生命周期注解语法
   生命周期注解并不改变任何引用的生命周期的长短, 与当函数签名指定了泛型类型参数
   后就可以接受任何类型一样, 当指定了泛型生命周期后函数也能接受任何生命周期的引
   用. 生命周期注解描述了多个引用生命周期相互的关系, 而不影响生命周期.

   生命周期参数名必须以撇号( ~'~ )开头, 其名称通常全是小写, 类似于泛型其名称非常短.
   ~'a~ 是大多数人默认使用的名称. 生命周期参数注解位于引用的 ~&~ 之后, 并有一个
   空格来将引用类型与生命周期注解分开.

   #+begin_src rust
     &i32 // 引用
     &'a i32 // 带有显式生命周期的引用
     &'a mut i32 // 带有显式生命周期的可变引用
   #+end_src
   
   单个的生命周期注解本身没有多少意义, 因为生命周期注解告诉 Rust 多个引用的泛型
   生命周期参数如何相互联系的. eg: 如果函数有一个生命周期 ~'a~ 的 ~i32~ 的引用的
   参数 ~first~. 还有另一个同样是生命周期 ~'a~ 的 ~i32~ 的引用的参数 ~second~.
   这两个生命周期注解意味着引用 ~first~ 和 ~second~ 必须与这泛型生命周期存在的一
   样久.

** 函数签名中的生命周期注解
   当函在函数中使用生命周期注解时, 这些注解出现在函数签名中, 而不存在与函数体中
   的任何代码中. 这是因为 Rust 能够分析中的代码而不需要任何协助, 不过当函数引用
   或被函数之外的代码引用时, 让 Rust 自身分析出参数或返回值的生命周期几乎是不可
   能的. 这些生命周期在每次函数被调用时都可能不同. 这也就是为什么我们需要手动标
   记生命周期.
   
** 深入理解生命周期
   当从函数返回一个引用, 返回值的 *生命周期需要与一个参数的生命周期参数相匹配*.
   如果返回的引用 *没有* 指向任何一个参数, 那么唯一的可能就是它指向一个函数内部
   创建的值, 它将会是一个悬垂引用, 因为它将会在函数结束时离开作用域.

   生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的. 一旦他们形
   成了某种关联, Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦
   或是违反内存安全的行为.

** 生命周期省略(Lifetime Elision)
   被编码进 Rust 引用分析的模式被称为 *生命周期省略规则(lifetime elision
   rules)*. 这并不是需要程序员遵守的规则; 这些规则是一系列特定的场景, 此时编译器
   会考虑, 如果代码符合这些场景, 就无需明确指定生命周期.

   省略规则并不提供完整的推断: 如果 Rust 在明确遵守这些规则的前提下变量的生命周
   期仍然是模棱两可的话, 它不会猜测剩余引用的生命周期应该是什么. 在这种情况, 编
   译器会给出一个错误, 这可以通过增加对应引用之间相联系的生命周期注解来解决.

   函数或方法的参数的生命周期被称为 *输入生命周期(input lifetimes)*, 而返回值的
   生命周期被称为 *输出生命周期(output lifetimes)*.

   编译器采用三条规则来判断引用何时不需要明确的注解. 第一条规则适用于输入生命周
   期, 后两条规则适用于输出声明周期. 如果编译器检查完这三条规则后仍然存在没有计
   算出生命周期的引用, 编译器将会停止并生成错误. 这些规则适用于 ~fn~ 定义, 以及
   ~impl~ 块.

   1. 每个是引用的参数都有它自己的生命周期函数. 即: 有一个引用参数的函数有一个生
      命周期参数: ~fn foo<'a>(x: &'a i32)~, 有两个引用参数的函数有两个不同的生命
      周期参数, ~fn foo<'a, 'b>(x: &'a i32, y: &'b i32)~, 依此类推.

   2. 如果只有一个输入生命周期参数, 那么它被赋予所有输出生命周期参数: 
      ~fn foo<'a>(x: &'a i32) -> &'a i32~

   3. 如果方法有多个输入生命周期参数并且其中一个参数是 ~&self~ 或 ~&mut self~,
      说明是个对象的方法(method), 那么所有输出生命周期参数被赋予 ~self~ 的生命周
      期. 该规则使得方法更容易读写, 因为只需要更少的符号.

      
   eg: 假设自己就是编译器. 并应用规则来实现 ~first_word~ 的函数签名
   #+begin_src rust
     fn first_word(s: &str) -> &str {}
   #+end_src

   接着用第一条规则, 每个引用参数都有自己的生命周期:
   #+begin_src rust
     fn first_word<'a>(s: &'a str) -> &str {}
   #+end_src
   
   对于第二条规则, 因为这里正好只有一个输入生命周期, 所以参数是通用的
   #+begin_src rust
     fn first_word<'a>(s: &'a str) -> &'a str{}
   #+end_src
   
   现在这个函数签名中的所有引用都有了生命周期, 如此编译器可以继续它的分析而无需
   程序员标记这个函数签名中的生命周期.

   eg2: 没有生命周期参数的 ~longest~:
   #+begin_src rust
     fn longest(x: &str, y: &str) -> &str {}
   #+end_src

   假设自己是编译器并应用第一条规则:
   #+begin_src rust
     fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {};
   #+end_src

   因为函数存在多个输入生命周期, 它无法应用第二条规则. 因为没有 ~self~ 参数, 它
   也不适用于第三条规则. 应用了 3 条规则发现还没有计算出返回值类型的生命周期. 这
   就是出现错误的原因.

   因为第三条规则真正能够使用的就只有方法签名. 接下来看看为什么这条规则意味着我
   们经常不需要在方法签名中标注生命周期.

** 方法定义中的生命周期注解
   当为带有生命周期的结构体实现方法时, 声明和生命周期参数的位置依赖于生命周期参
   数是否同结构体字段或方法参数和返回值相关.

   (实现方法时)结构体字段的生命周期必须总是在 ~impl~ 关键字之后声明并在结构体名
   称之后被使用, 因为这些生命周期是结构体类型的一部分.

   ~impl~ 块里的方法签名中, 引用可能与结构体字段中的引用相关联, 也可能是独立的.
   另外, 生命周期省略规则也经常让我们无需在方法签名中使用生命周期注解.

** 静态生命周期
   ~'static~: 其生命周期能过存活于 *整个程序* 期间. 所有的字符串字面值都拥有
   ~'static~ 生命周期, 也可以显式标注.

   这些字符串的文本被直接存储在程序的二进制文件中而这个文件总是可用的. 因此所有
   的字符串字面值都是 ~'static~ 的.

   大部分情况, 代码中的问题是尝试创建一个悬垂引用或者可用的生命周期不匹配, 请解
   决这些问题而不是指定一个 ~'static~ 的生命周期

   
** 总结
   泛型类型参数意味着代码可以适用于不同的类型. ~trait~ 和 ~trait bounds~ 保证了
   即使类型是泛型的, 这些类型也会拥有所需要的行为. 由生命周期注解所指定的引用生
   命周期之间的关系保证了这些灵活多变的代码不会出现悬垂引用. 而这所有的这一切发
   生在 *编译时* 所以不会影响运行时效率
