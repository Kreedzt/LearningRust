* 字符串
  Rust 的核心语言中只有 *一种字符串类型: ~str~*, 字符串 slice, 通常以 *被借用*
  的形式出现, ~&str~.

  *字符串 slice*: 是一些存储在别处的 UTF-8 编码的字符串数据的 *引用*. eg: 字符串
   字面值被存储在程序的二进制输出中, 亦是如此.

  称作 ~String~ 的类型是由标准库提供的, 而没有写进核心语言部分, 它是可增长的, 可
  变的, 有所有权的, UTF-8 编码的字符串类型.

** 索引字符串
   ~String~ 是一个 ~Vec<u8>~ 的封装.
   
   每个 Unicode 标量值需要 2 个字节存储. 因此:
   一个字符串字节的值的索引 *并不总是对应一个有效的 Unicode 标量值*.

   以下为 *无效* 代码:
   #+begin_src rust
     let hello = "Здравствуйте";
     let answer = &hello[0];
   #+end_src

   此时: ~3~ 的第一个字节 ~208~, ~answer~ 实际上应该是 ~208~, 不过 ~208~ 自身
   *并不是* 一个有效的字母, 返回 ~208~ 可能不是一个请求字符串的第一个字母的人想
   看到的. 所以 Rust *根本不会编译这些代码*.

** 字节, 标量值和字形簇
   从 Rust 的角度来讲, 有三种相关方式可以理解字符串: 字节, 标量值和字形簇(最接近
   字母的概念).

   "     let hello = "Здравствуйте";
     let answer = &hello[0];
   #+end_src

   此时: ~3~ 的第一个字节 ~208~, ~answer~ 实际上应该是 ~208~, 不过 ~208~ 自身
   *并不是* 一个有效的字母, 返回 ~208~ 可能不是一个请求字符串的第一个字母的人想
   看到的. 所以 Rust *根本不会编译这些代码*.

** 字节, 标量值和字形簇
   从 Rust 的角度来讲, 有三种相关方式可以理解字符串: 字节, 标量值和字形簇(最接近
   字母的概念).

   "नमस्ते" 存储在 vector 中的 ~u8~ 值类似如下:
   #+begin_src text
     [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]
   #+end_src

   这里有 18 个 *字节*, 从 Unicode 标量值的角度理解, 类似如下:
   #+begin_src text
     ['न', 'म', 'स', '्', 'त', 'े']
   #+end_src

   这里有 6 个 ~char~, 但第 4 个和 第 6 个都不是字母, 发音符号本身没有任何意义.
   最后, 如果以字形簇的角度理解, 就会得到人们所说的构成这个单词的 4 个字母:
   #+begin_src text
     ["न", "म", "स्", "ते"]
   #+end_src

   最后一个 Rust 不允许使用索引获取 ~String~ 字符的原因是:
   索引操作预期总数需要常数时间 (O(1)). 但是对于 ~String~ 不可能保证这样的性能,
   因为 Rust 必须从开头到索引位置遍历来确定有多少个有效字符.

** 字符串 slice
   可以使用 ~[]~ 和一个 range 来创建一个 *含特定字节* 的字符串 slice:

** 遍历字符串
   从字符串中获取字形簇是很复杂的, 所以标准库 *并没有* 提供这个功能.
