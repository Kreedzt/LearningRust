* 使用 Sync 和 Send trait 的可扩展并发
  Rust 的并发模型中一个有趣的方面是: 语言本身对并发知之 *甚少*. 至今讨论的都属于
  标准库, 而不是语言本身的内容. 由于不需要语言提供并发相关的基础设施, 并发方案不
  受标准库或语言所限: 我们可以编写自己的或使用别人编写的并发功能.

  有两个并发概念是内嵌于语言中的: ~std::marker~ 中的 ~Sync~ 和 ~Send~ trait.

** 通过 Send 允许在线程间转移所有权
   ~Send~ 标记 trait 表明类型的所有权可以在线程间传递. 几乎所有的 Rust 类型都是
   ~Send~ 的, 不过有一些例外, 包括 ~Rc<T>~: 这是不能 ~Send~ 的, 因为如果克隆了
   ~Rc<T>~ 的值并尝试将克隆的所有权转移到另一个线程, 这两个线程都可能同时更新引
   用计数. 为此, ~Rc<T>~ 被实现为用于单线程场景, 这时必须要为拥有线程安全的引用
   计数而付出性能代价.

   因此, Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 ~Rc<T>~ 在线
   程间发送. 当尝试这么做的时候, 会得到错误:
   ~the trait Send is not implemented for Rc<Mutex<i32>>~. 而标记为 ~Send~ 的
   ~Arc<T>~ 时, 就没有问题.

   任何完全由 ~Send~ 的类型组成的类型也被自动标记为 ~Send~. 几乎所有基本类型都是
   ~Send~ 的.除了 19 章涉及的裸指针(raw pointer).

** Sync 允许多线程访问
   ~Sync~ 标记 trait 表明一个实现了 ~Sync~ 的类型可以安全的在多个线程中拥有其值
   的引用. 对于任意类型 ~T~, 如果 ~&T~ (~T~ 的引用) 是 ~Send~ 的话 ~T~ 就是
   ~Sync~ 的, 这意味着其引用就可以安全的发送到另一个线程. 类似于 ~Send~ 的情况,
   基本类型就是 ~Sync~ 的, 完全由 ~Sync~ 的类型组成的类型也是 ~Sync~ 的.

   智能指针 ~Rc<T>~ 也不是 ~Sync~ 的, 处于不是 ~Send~ 相同的原因. ~RefCell<T>~
   和 ~Cell<T>~ 系列类型不是 ~Sync~ 的. ~RefCell<T>~ 在运行时所进行的借用检查也
   不是线程安全的.

   ~Mutex<T>~ 是 ~Sync~ 的, 可以被用来在多线程中共享访问.

** 手动实现 Send 和 Sync 是不安全的
   通常并不需要手动实现 ~Send~ 和 ~Sync~ trait, 因为由 ~Send~ 和 ~Sync~ 的类型组
   成的类型, 自动就是 ~Send~ 和 ~Sync~ 的. 因为他们是标记 trait, 甚至都不需要实
   现任何方法. 他们只是用来加强并发相关的不可变性的.

   手动实现这些标记 trait 涉及到编写不安全的 Rust 代码(19 章). 当前重要的是: 在
   创建新的由不是 ~Send~ 和 ~Sync~ 的部分构成的并发类型时要多加小心, 以确保维持
   其安全保证.

