* 引用与借用
  使用 ~String~ 类型作为函数的参数时, 进入函数即拿到所有权, 退出后 *被销毁*.
  使用 ~&~ 符号可以仅获得引用, *不取得所有权*
  解引用: ~*~
  可变引用: ~&mut~

  将获取引用作为函数的参数称为 *借用(borrowing)*

  可变引用有一个很大的限制：在特定作用域中的特定数据只能有 *一个可变引用*
  这是为了避免 *数据竞争(data race)*:
  - 两个或更多指针同时访问同一数据
  - 至少有一个指针被用来写入数据
  - 没有同步数据访问的机制

    
  数据竞争会导致未定义行为, 难以在运行时追踪, 难以诊断和修复;

  同时使用可变引用和不可变引用也会导致问题

  *注意*: 一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。

** 悬垂引用(Dangling References)
   在具有指针的语言中, 很容易通过释放内存时保留指向它的指针而错误地生成一个悬垂
   指针(dangling pointer), 其指向的内存可能已经被分配给其他持有者. 相比之下,
   Rust 编译器确保永远不会出现此状况, 当你有一些引用, 编译器确保数据不会在其引用
   之前离开作用域
   
** 引用的规则
   1. 在任意给定时间, 要么 *只能有一个可变引用*, 要么 *只能多个不可变引用*
   2. 引用必须总是有效的

