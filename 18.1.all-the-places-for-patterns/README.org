* 所有可能会用到的位置
** match 分支
   一个模式常用的位置是 ~match~ 表达式的分支. 在形式上 ~match~ 表达式由 ~match~
   关键字, 用于匹配的值和一个或多个分支构成, 这些分支包含一个模式和在值匹配分支
   的模式时运行的表达式:

   #+begin_src rust
     match VALUE {
         PATTERN => EXPRESSION,
         PATTERN => EXPRESSION,
         PATTERN => EXPRESSION,
     }
   #+end_src

   ~match~ 表达式必须是 *穷尽(exhaustive)* 的, 意为 ~match~ 表达式所有可能的值都
   必须被考虑到. 一个确保覆盖每个可能值的方法是在最后一个分支使用捕获所有的模式:
   比如, 一个匹配任何值的名称也永远不会失败, 因此可以覆盖所有匹配剩下的情况.

   有一个特定模式 ~_~ 可以匹配所有情况, 不过它从不绑定任何变量. 这在希望忽略任何
   未指定的情况很有用. 本章之后的 "忽略模式的值" 部分会详细介绍 ~_~ 模式的更多细
   节.

** if let 条件表达式
   ~if let~ 也可以像 ~match~ 分支那样引入覆盖变量: ~if let Ok(age) = age~ 引入了
   一个新的覆盖变量 ~age~, 它包含 ~Ok~ 成员中的值. 这意味着 ~if age > 30~ 条件需
   要位于这个代码块内部; 不能将两个条件组合为 ~if let Ok(age) = age && age >
   30~, 因为我们希望与 30 进行比较的被覆盖的 ~arg~ 直到大括号开始的新作用域才是
   有效的.

   ~if let~ 表达式的缺点在于其穷尽性没有为编译器所检查, 而 ~match~ 表达式则检查
   了. 如果去掉最后的 ~else~ 块而遗漏处理一些情况, 编译器也不会警告这类可能的逻
   辑错误.

** 函数参数
   模式在每个使用它的地方并不以相同的方式工作; 在一些地方, 模式必须是
   irrefutable 的, 意味着他们必须匹配所提供的任何值. 在另一些情况, 他们则可以是
   refutable 的.
