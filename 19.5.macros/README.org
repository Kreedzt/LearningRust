* 宏
  *宏(Macro)* 指的是 Rust 中一系列的功能: *声明(Declarative)* 宏, 使用
   ~macro_rules!~, 和三种 *过程(Procedural)* 宏:

   - 自定义 ~#[derive]~ 宏在结构体和枚举上指定通过 ~derive~ 属性添加的代码
   - 类属性 (Attribute-like) 宏定义可用于任意项的自定义属性
   - 类函数宏看起来像函数不过作用域作为函数传递的 token.
  
** 宏和函数的区别
   从根本上来说, 宏是一种为其他代码而写代码的方式, 即所谓的 *元编程
   (metaprogramming)*. (附录 C 中会探讨 ~derive~ 属性) 其生成各种 trait 的实现.
   所有的这些宏以 *展开* 的方式来生成比手写出的更多的代码.

   元编程对于减少大量编写和维护的代码是非常有用的, 它也扮演了函数扮演的角色. 但
   宏有一些函数所没有的附加能力.

   一个函数标签必须声明函数参数个数和类型. 相比之下, 宏能够接受不同数量的参数:
   用一个参数调用 ~println!("hello")~ 或用两个参数调用 ~println!("hello {}",
   name)~. 而且, 宏可以在编译器翻译代码前展开, eg: 宏可以在一个给定类型上实现
   trait. 而函数则不行, 因为函数是运行时调用, 同时 trait 需要在编译时实现.

   实现一个宏而不是函数的消极面是宏定义要比函数定义更复杂, 因为正在编写 Rust 代
   码的 Rust 代码. 由于这样的间接性, 宏定义通常要比函数定义更难阅读, 理解和维护.

   宏和函数的最后一个重要的区别是: 在一个文件里调用宏 *之前* 必须定义它, 或将其
   引入作用域, 而函数则可以在任何地方定义和调用.

** 使用 macro_rules! 的声明宏用于通常元编程
   Rust 最常用的宏形式是 *声明宏(declarative macros)*. 它们有时也被称为 "macros
   by example", "~macro_rules~ 宏" 或者就是 "macros". 其核心概念是, 声明宏允许我
   们编写一些类似 Rust ~match~ 表达式的代码, ~match~ 表达式是控制结构, 其接受一
   个表达式, 与表达式的结果进行模式匹配, 然后根据模式匹配执行相关代码. 宏也将一
   个值和包含相关代码的模式进行比较; 这种情况下, 该值是传递给宏的 Rust 源代码字
   面值, 模式用于和 传递给宏的源代码进行比较, 同时每个模式的相关代码则用于替换传
   递给宏的代码. 所有这一切都发生与编译时.

   可以使用 ~macro_rules!~ 来定义宏

   无论何时导入定义了宏的包, ~#[macro_export]~ 注解说明宏应该是可用的. 如果没有
   该注解, 这个宏不能被引入作用域.

   一堆括号包含了整个模式. ~$~ 后跟一对括号, 不活了符合括号内模式的值以用于替换
   后的代码. ~$()~ 内则是 ~$x:expr~, 其匹配 Rust 的任意表达式, 并将表达式记作
   ~$x~.

   ~$()~ 之后的逗号说明一个可有可无的逗号分隔符可以出现在 ~$()~ 所匹配的代码之后.
   金穗逗号之后的 ~*~ 说明该模式匹配 0 个或更多个 ~*~ 之前的任何模式.

   当以 ~vec![1, 2, 3];~ 调用宏时, ~$x~ 模式与三个表达式 ~1~, ~2~, ~3~ 进行三次
   匹配. 

   在将来, 会有第二种采用 ~macro~ 关键字的声明宏, 其工作方式类似但修复了这些极端
   情况. 在此之后, ~macro_rules!~ 实际上就过时了(deprecated). 在此基础上, 同时鉴
   于大多数 Rust 程序员 *使用* 宏而非 *编写* 宏的事实, 此处不再深入探讨 ~macro_rules!~

** 用于从属性生成代码的过程宏
   第二种形式的宏被称为 *过程宏(procedural macros)*, 因为他们更像函数(一种过程类
   型). 过程宏接收 Rust 代码作为输入, 在这些代码上进行操作, 然后产生另一些代码作
   为输出, 而非像声明式宏那样匹配对于模式然后以另一部分代码替换当前代码.

   有三种类型的过程宏(自定义派生(derive), 类属性和类函数), 不过它们的工作方式都
   类似.

   当创建过程宏时, 其定义必须位于一种特殊类型的属于它们的 crate 中. 这么做处于复
   杂的技术原因, 将来我们希望能够消除这些限制.

   #+begin_src rust
     use proc_macro;

     #[some_attribute]
     pub fn some_name(input: TokenStream) -> TokenStream {}
   #+end_src

   过程宏包含一个函数, 这也是其得名的原因: "过程" 是 "函数" 的同义词. 有一个过程
   宏是 "类函数" 的, 叫成函数会产生混乱. 无论如何, 定义过程宏的函数接受一个
   ~TokenSteam~ 作为输入并产生一个 ~TokenStream~ 作为输出. 这也就是宏的核心: 宏
   所处理的源代码组成了输入 ~TokenStream~, 同时宏生成的代码是输出 ~TokenStream~.
   最后, 函数上有一个属性; 这个属性表明过程宏的类型. 在同一 crate 中可以有多种的
   过程宏.

** 如何编写自定义 derive 宏
** 类属性宏
   类属性宏与自定义派生宏相似, 不同为 ~derive~ 属性生成代码, 它们允许创建新的属
   性. 它们也更为灵活; ~derive~ 只能用于结构体和枚举; 属性还可以用于其他的项, 比
   如函数. 作为一个使用类属性宏的例子, 可以创建一个名为 ~route~ 的属性用于注解
   web 应用程序框架(web application framework) 的函数:
   
   #+begin_src rust
     #[route(GET, "/")]
     fn index() {}
   #+end_src

   ~#[route]~ 属性将由框架本身定义为一个过程宏. 其宏定义的函数签名看起来像这样:
   #+begin_src rust
     #[proc_macro_attribute]
     pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {}
   #+end_src

   这里有两个 ~TokenStream~ 类型的参数; 第一个用于属性内容本身, 也就是 ~GET,
   "/"~ 部分. 第二个是属性所标记的项: 在本例中, 是 ~fn index() {}~ 和剩下的函数
   体.

   处理之外, 类属性宏与自定义派生宏工作方式一致: 创建 ~proc_macro~ crate 类型的
   crate 并实现生成代码的函数!

** 类函数宏
   类函数宏的定义看起来像函数调用的宏. 类似于 ~macro_rules!~, 它们比函数更灵活;
   eg: 可以接受未知数量的参数. 然而 ~macro_rules!~ 宏只能使用之前元编程介绍的类
   型匹配的语法定义. 类函数获取 ~TokenStream~ 参数, 其定义使用 Rust 代码操纵
   ~TokenStream~, 就像另两种过程宏一样. 一个类函数的例子是可以像这样背调用的
   ~sql!~ 宏:
   #+begin_src rust
     let sql = sql!(SELECT * FROM posts WHERE id=1);
   #+end_src

   这个宏会解析其中的 SQL 语句并检查其是否是句法正确的, 这是比 ~macro_rules~~ 可
   以做到更为复杂的处理. ~sql!~ 宏应该被定义为如此:
   #+begin_src rust
     #[proc_macro]
     pub fn sql(input: TokenStream) -> TokenStream {}
   #+end_src

   这类似于自定义派生宏的签名: 获取括号中的 token, 并返回希望生成的代码.
