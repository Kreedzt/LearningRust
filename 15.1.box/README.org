* 使用 Box<T> 指向堆上的数据
  最简单直接的智能指针是 box, 其类型是 ~Box<T>~. box 允许你将一个值放在堆上而不
  是栈上. 留在栈上的则是指向堆数据的指针.

  除了数据被储存在堆上而不是栈上之外, box *没有性能损失*, 不过也没有很多额外的功
  能, 多用于如下场景:
  - 当有一个在编译时未知大小的类型, 而又想要在需要确切大小的上下文中使用这个类型
    值的时候
  - 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
  - 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是具体其类型的时候

  我们会在 "box 允许创建递归类型" 部分展示第一种场景. 第二种情况中, 转移大量数据
  的所有权可能会花费很长的时间, 因为数据在栈上进行了拷贝. 为了改善这种情况下的性
  能, 可以通过 box 将这些数据储存在堆上. 接着, 只有少量的指针数据在栈上被拷贝.
  第三种情况被称为 *trait 对象(trait object)*, 第十七章有此内容: "为使用不同类型
  的值而设计的 trait 对象".

** Box 允许创建递归类型
   Rust 需要在编译时知道类型占用多少空间. 一种无法在编译时知道大小的类型是 *递归
   类型(recursive type)*, 其值的一部分可以是相同类型的另一个值. 这种值得嵌套理论
   上可以无限的进行下去, 所以 RUst 不知道递归类型需要多少空间. 不过 box 有一个已
   知的大小, 所以通过在循环类型定义中插入 box, 就可以创建递归类型了.

*** cons list 的更多内容
    cons list 是一个来源于 Lisp 编程语言及其方言的数据结构. 在 Lisp 中, ~cons~
    函数 ("construct function" 的缩写) 利用两个参数来构造一个新的列表, 他们通常
    是一个单独的值和另一个列表.

    cons 函数的概念涉及到更常见的函数式编程术语: "将 x 与 y 连接" 通常意味着构建
    一个新的容器将 x 的元素放在新容器的开头, 其后则是容器 y 的元素.

    cons list 的每一项都包含两个元素: 当前项的值和下一项. 其最后一项包含一个叫做
    ~Nil~ 的值且没有下一项, 它宣布列表的终止. 注意: 这不同于第六章的 "null" 或
    "nil" 的概念, 他们代表无效或缺失的值.

    虽然函数式编程语言经常使用 cons list, 但是它 *并不是* 一个 Rust 中常见的类型.
    大部分在 Rust 中需要列表的时候, ~Vec<T>~ 是一个更好的选择. 其他更为复杂的递
    归数据类型 *确实* 在 Rust 的很多场景中有用, 不过通过以 cons list 作为开始,
    我们可以探索如何使用 box 毫不费力的定义一个递归数据类型.
    
